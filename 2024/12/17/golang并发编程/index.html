<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  
    <link rel="icon" href="/assets/favicon.png">
  
  
  <title>golang并发编程 | Kid</title>
  <link rel="canonical" href="http://example.com/2024/12/17/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
  <meta name="author" content="kid" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="" />
  
  <meta name="description" content="1.Goruntine和Changoruntine是go的协程，chan是为了实现goruntine之间的通讯，go并发的思想是通过通信来共享内存，而不是通过共享内存来通信。相比于java使用thread，goruntine更加轻量级，包含了CPU上下文。而对于并发安全问题，java使用各种同步机制如synchronized关键字、ReentrantLock、Semaphore等，来保证多线程程序">
<meta property="og:type" content="article">
<meta property="og:title" content="golang并发编程">
<meta property="og:url" content="http://example.com/2024/12/17/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Kid">
<meta property="og:description" content="1.Goruntine和Changoruntine是go的协程，chan是为了实现goruntine之间的通讯，go并发的思想是通过通信来共享内存，而不是通过共享内存来通信。相比于java使用thread，goruntine更加轻量级，包含了CPU上下文。而对于并发安全问题，java使用各种同步机制如synchronized关键字、ReentrantLock、Semaphore等，来保证多线程程序">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/12/17/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/img.png">
<meta property="article:published_time" content="2024-12-17T10:48:47.000Z">
<meta property="article:modified_time" content="2025-06-28T09:08:59.900Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/12/17/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/img.png">
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kr-core.min.css" media="all"></link>
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/highlight.js/night-eighties.min.css" media="all"></link>
  
  <link rel="stylesheet" id="theme-light-css" href="/css/kr-theme/light.min.css" media="all"></link>
  <link rel="stylesheet" id="theme-dark-css" href="/css/kr-theme/dark.min.css" media="(prefers-color-scheme: dark)"></link>
  <script src="/js/kr-theme.min.js"></script>
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></link>
  
    <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></link>
  
  
    <link rel="stylesheet" href="/vendors/viewerjs@1.11.6/dist/viewer.min.css"></link>
  
  <!-- 不得不预先加载的一些JS文件 -->
  
    <script src="/vendors/qr-code-styling@1.6.0-rc.1/lib/qr-code-styling.js"></script>
  
  <!-- 自定义站点横幅和背景 -->
  <style>
    
      .kratos-cover.kratos-cover-2 {
        background-image: url('https://dev.krt.moe/demo-assets/banner.webp');
      }
      html[data-theme="dark"] .kratos-cover.kratos-cover-2 {
        background-image: url('https://dev.krt.moe/demo-assets/banner_dark.webp');
      }
    
    
      @media(min-width:768px) {
        body.custom-background {
          background-image: url('https://dev.krt.moe/demo-assets/bg.webp');
        }
        html[data-theme="dark"] body.custom-background {
          background-image: url('https://dev.krt.moe/demo-assets/bg.webp');
        }
      }
    
    
      .widget-kratos-about .photo-background {
        background-image: url('/images/default.webp');
      }
      html[data-theme="dark"] .widget-kratos-about .photo-background {
        background-image: url('/images/default.webp');
      }
    
  </style>

  <!-- 额外的追加注入项 -->
  
<meta name="generator" content="Hexo 7.3.0"></head>

    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    <li>
                                        
                                            <a href="/">
                                        
                                            
                                                <i class="fa fa-home"></i>
                                            
                                            首页
                                        </a>
                                        
                                    </li>
                                
                                    <li>
                                        
                                            <a href="/archives/">
                                        
                                            
                                                <i class="fa fa-file"></i>
                                            
                                            档案馆
                                        </a>
                                        
                                    </li>
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">Kid</a></div>
                    <div id="kratos-nav-toggle-wrapper" class="nav-toggle">
                        <a id="kratos-nav-toggle" class="kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>Kid</h2> <br />
                        <span></span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">


        

            

            <section class="kr-main-col col-md-8">

        

            <article itemscope itemtype="https://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/17/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
    <div class="kratos-hentry kratos-page-inner clearfix">
        <header class="kratos-page-header">
            
                <h1 class="kratos-page-title text-center" itemprop="name headline">golang并发编程</h1>
            
            <ul class="kratos-page-meta text-center">
                <li><time datetime="2024-12-17T10:48:47.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2024-12-17</time></li>
                <li itemprop="author" itemscope itemtype="https://schema.org/Person">
                    <i class="fa fa-user"></i> 作者 <span itemprop="name">kid</span>
                </li>
                
                    <li>
                        <i class="fa fa-edit"></i> 
                        
                        
                            ~14.80K
                        
                        字
                    </li>
                
                
                
            </ul>
        </header>
        <div class="kratos-page-content kr-post">
            
            
            
            <hr />
            <div itemprop="articleBody"><h1 id="1-Goruntine和Chan"><a href="#1-Goruntine和Chan" class="headerlink" title="1.Goruntine和Chan"></a>1.Goruntine和Chan</h1><p>goruntine是go的协程，chan是为了实现goruntine之间的通讯，go并发的思想是通过通信来共享内存，而不是通过共享内存来通信。相比于java使用thread，goruntine更加轻量级，包含了CPU上下文。而对于并发安全问题，java使用各种同步机制如synchronized关键字、ReentrantLock、Semaphore等，来保证多线程程序的并发安全性。但是，使用Java进行线程管理需要手动管理线程的生命周期和资源，容易出现线程安全问题。Go语言通过Channel机制来保证goroutine之间的安全通信，使得并发编程更加简单和安全。由于Channel是一种基于消息传递的通信方式，因此不会出现死锁和资源竞争等问题。此外，Go语言的运行时系统会自动管理goroutine的调度和资源，减少了开发者的负担，提高了程序的稳定性和安全性。</p>
<h3 id="避免数据竞争的三种方式："><a href="#避免数据竞争的三种方式：" class="headerlink" title="避免数据竞争的三种方式："></a>避免数据竞争的三种方式：</h3><ol>
<li>不去写变量。读取不可能出现数据竞争。</li>
<li>避免从多个 goroutine 访问变量，尽量把变量限定在了一个单独的 goroutine 中。(使用 channel 来共享数据)</li>
<li>互斥锁</li>
</ol>
<h3 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h3><p>Goroutine 是 Go 语言中实现并发的核心机制。它是一种轻量级的线程，拥有自己的栈空间和程序计数器，但与系统线程相比，它具有以下特点：</p>
<ul>
<li><strong>创建和销毁成本低</strong>：Goroutine 的创建和销毁只需很少的系统资源，因此可以轻松创建大量的 Goroutine。</li>
<li><strong>调度</strong>：Go 语言的运行时会自动调度 Goroutine 在多个 CPU 上执行，充分利用多核 CPU 的资源。</li>
<li><strong>非抢占式</strong>：Goroutine 是非抢占式的，这意味着它不会抢占其他 Goroutine 正在运行的 CPU 时间。</li>
</ul>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel 是 Go 语言中用于 goroutine 之间通信的管道。它可以用来传递数据、同步执行等。<br>Channel 具有以下特点：</p>
<ul>
<li><strong>类型化</strong>：Channel 可以是特定类型的，这意味着只能发送和接收该类型的数据。</li>
<li><strong>容量</strong>：Channel 可以有容量限制，这意味着它可以同时存储一定数量的数据。</li>
<li><strong>阻塞</strong>：Channel 可以是阻塞的，这意味着如果尝试从空 Channel 中接收数据或向满 Channel 中发送数据，操作将会阻塞，直到有数据可供接收或有空间可供发送。<br><img src="/2024/12/17/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Pasted%20image%2020250317162025.png"><br>当主协程接收到 10 个信号后，所有协程都已经完成任务，不会再向通道发送数据。此时，主协程尝试第 11 次从通道接收数据，由于通道中没有新的数据，且没有协程会再发送数据，主协程就会一直阻塞，最终导致死锁错误。而关闭通道可以向接收方表明不会再有新的数据发送到通道中。接收方在通道关闭后，仍然可以从通道中接收已有的数据，当所有数据都被接收后，接收操作会立即返回通道元素类型的零值和一个布尔值 <code>false</code>，表示通道已关闭。<br>使用chan后要释放chan，否则会出现一直读取chan的情况，发生死锁（deadlock！！）<br><img src="/2024/12/17/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Pasted%20image%2020250317163039.png"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;  </span><br><span class="line">    messageCh := make(chan int, 10)  </span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;  </span><br><span class="line">       messageCh &lt;- i  </span><br><span class="line">    &#125;  </span><br><span class="line">    close(messageCh)  </span><br><span class="line">  </span><br><span class="line">    for &#123;  </span><br><span class="line">       time.Sleep(time.Second)  </span><br><span class="line">       msg, ok := &lt;-messageCh  </span><br><span class="line">       if !ok &#123;  </span><br><span class="line">          break  </span><br><span class="line">       &#125;  </span><br><span class="line">       fmt.Printf(&quot;msg:%v, ok:%v\n&quot;, msg, ok)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="2-时机控制WaitGroup"><a href="#2-时机控制WaitGroup" class="headerlink" title="2.时机控制WaitGroup"></a>2.时机控制WaitGroup</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;  </span><br><span class="line">    start := time.Now()  </span><br><span class="line">    var wg sync.WaitGroup  </span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;  </span><br><span class="line">       wg.Add(1)  </span><br><span class="line">       go doSome(i, &amp;wg)  </span><br><span class="line">    &#125;  </span><br><span class="line">    wg.Wait()  </span><br><span class="line">    fmt.Println(&quot;use time:  &quot;, time.Since(start))  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">func doSome(number int, wg *sync.WaitGroup) &#123;  </span><br><span class="line">    time.Sleep(time.Millisecond * 100)  </span><br><span class="line">    fmt.Printf(&quot;result: %d\n&quot;, number)  </span><br><span class="line">    wg.Done()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-流程控制Select"><a href="#3-流程控制Select" class="headerlink" title="3.流程控制Select"></a>3.流程控制Select</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">type MessageServer struct &#123;  </span><br><span class="line">    messageCh chan string  </span><br><span class="line">    quitCh    chan struct&#123;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">func NewMessageServer() *MessageServer &#123;  </span><br><span class="line">    return &amp;MessageServer&#123;  </span><br><span class="line">       messageCh: make(chan string, 100),  </span><br><span class="line">       quitCh:    make(chan struct&#123;&#125;, 1),  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">func sendMessage(s *MessageServer, message string) &#123;  </span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;  </span><br><span class="line">       s.messageCh &lt;- message  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">func (s *MessageServer) handleMessage(message string) &#123;  </span><br><span class="line">    fmt.Println(&quot;get message: &quot;, message)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">func (s *MessageServer) work() &#123;  </span><br><span class="line">    for &#123;  </span><br><span class="line">       select &#123;  </span><br><span class="line">       case msg := &lt;-s.messageCh:  </span><br><span class="line">          s.handleMessage(msg)  </span><br><span class="line">       case &lt;-s.quitCh:  </span><br><span class="line">          return  </span><br><span class="line">       default:  </span><br><span class="line">          s.quitCh &lt;- struct&#123;&#125;&#123;&#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">func main() &#123;  </span><br><span class="line">    server := NewMessageServer()  </span><br><span class="line">    sendMessage(server, &quot;hello world&quot;)  </span><br><span class="line">    server.work()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-Mutex和Atomic"><a href="#4-Mutex和Atomic" class="headerlink" title="4.Mutex和Atomic"></a>4.Mutex和Atomic</h1><p>防止data race问题（多线程竞争同一资源），做data race检查最好在go test中做</p>
<h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><p>类似java中的锁（我感觉都一样）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">type Counter struct &#123;  </span><br><span class="line">    sync.Mutex  </span><br><span class="line">    number int  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">func (c *Counter) AddNumber(i int, wg *sync.WaitGroup) &#123;  </span><br><span class="line">    c.Mutex.Lock()  </span><br><span class="line">    defer c.Mutex.Unlock()  </span><br><span class="line">    c.number += i  </span><br><span class="line">    wg.Done()  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">func main() &#123;  </span><br><span class="line">    start := time.Now()  </span><br><span class="line">    num := 0  </span><br><span class="line">    for i := 0; i &lt; 1000000; i++ &#123;  </span><br><span class="line">       num += i  </span><br><span class="line">    &#125;  </span><br><span class="line">    fmt.Printf(&quot;num: %d, time: %v\n&quot;, num, time.Since(start))  </span><br><span class="line">    start = time.Now()  </span><br><span class="line">    counter := &amp;Counter&#123;&#125;  </span><br><span class="line">    var wg sync.WaitGroup  </span><br><span class="line">    for i := 0; i &lt; 1000000; i++ &#123;  </span><br><span class="line">       wg.Add(1)  </span><br><span class="line">       go counter.AddNumber(i, &amp;wg)  </span><br><span class="line">    &#125;  </span><br><span class="line">    wg.Wait()  </span><br><span class="line">    fmt.Printf(&quot;num: %d, time: %v\n&quot;, counter.number, time.Since(start))  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-sync包"><a href="#5-sync包" class="headerlink" title="5.sync包"></a>5.sync包</h1><h2 id="1-sync包工具"><a href="#1-sync包工具" class="headerlink" title="1.sync包工具:"></a>1.sync包工具:</h2><p>Mutex： 互斥锁<br>RWMutex：读写锁<br>WaitGroup：并发等待组<br>Map：并发安全字典<br>Once：单例模式<br>Cond：同步等待条件<br>Pool：临时对象池</p>
<h2 id="2-sync-Mutex-互斥锁"><a href="#2-sync-Mutex-互斥锁" class="headerlink" title="2.sync.Mutex(互斥锁)"></a>2.sync.Mutex(互斥锁)</h2><p><code>sync.Mutex</code> 的结构体：<br><img src="/2024/12/17/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Pasted%20image%2020250317182527.png"><br>在默认状态下，互斥锁的所有状态位都是 0，<code>int32</code> 中的不同位分别表示了不同的状态：</p>
<ul>
<li><code>locked</code>：表示这个锁是否被持有</li>
<li><code>woken</code>：表示是否从有唤醒的 goroutine</li>
<li><code>starving</code>：表示此锁是否进入饥饿状态</li>
<li><code>waitersCount</code>：表示等待此锁的 goroutine 的数量</li>
</ul>
<h3 id="饥饿模式"><a href="#饥饿模式" class="headerlink" title="饥饿模式"></a>饥饿模式</h3><p>请求锁的 goroutine 有两类，一类是新来请求锁的 goroutine，另一类是被唤醒的等待请求锁的 goroutine。<br>由于新来的 goroutine 也参与竞争锁，极端情况下，等待中的 goroutine 可能一直获取不到锁，这就是<strong>饥饿问题</strong>。<br>为了解决饥饿，Go为 mutex 增加了<strong>饥饿模式</strong>。<br>在正常模式下，等待中的 goroutine 会按照先进先出的顺序获取锁。但是如果新来的 goroutine 竞争锁，等待中的 goroutine 大概率是获取不到锁的。一旦 goroutine 超 过 1ms 没有获取到锁，它就会将当前互斥锁切换到饥饿模式，保证锁的公平性。<br>在饥饿模式中，互斥锁会直接交给等待队列最前面的 goroutine。新来的 goroutine 在该状态下不能获取锁、也不会进入自旋状态，只会在队列的末尾等待。<br>下面两种情况，mutex 会切换为正常模式:</p>
<ul>
<li>一个 goroutine 获得了锁并且它在队列的末尾</li>
<li>一个 goroutine 等待的时间少于 1ms</li>
</ul>
<h3 id="Mutex-Lock-的实现"><a href="#Mutex-Lock-的实现" class="headerlink" title="Mutex.Lock() 的实现"></a>Mutex.Lock() 的实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    mutexLocked = 1 &lt;&lt; iota // 1</span><br><span class="line">    mutexWoken // 2</span><br><span class="line">    mutexStarving // 4</span><br><span class="line">    mutexWaiterShift = iota // 3</span><br><span class="line">	starvationThresholdNs = 1e6 // 1000000</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func (m *Mutex) Lock() &#123;</span><br><span class="line">    // Fast path: grab unlocked mutex.</span><br><span class="line">	// 没有 goroutine 持有锁，也没有等待的 goroutine，当前 goroutine 可以直接获得锁</span><br><span class="line">    if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) &#123;</span><br><span class="line">        if race.Enabled &#123;</span><br><span class="line">            race.Acquire(unsafe.Pointer(m))</span><br><span class="line">        &#125;</span><br><span class="line">	    return</span><br><span class="line">	&#125;</span><br><span class="line">    // Slow path (outlined so that the fast path can be inlined)</span><br><span class="line">	// 通过自旋等方式竞争锁</span><br><span class="line">    m.lockSlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *Mutex) lockSlow() &#123;</span><br><span class="line">	var waitStartTime int64</span><br><span class="line">	starving := false // 当前 goroutine 的饥饿标记</span><br><span class="line">	awoke := false // 唤醒标记</span><br><span class="line">	iter := 0 // 自旋次数</span><br><span class="line">	old := m.state // 当前锁的状态</span><br><span class="line">	for &#123;</span><br><span class="line">		// 锁是非饥饿模式并且还没被释放，尝试自旋</span><br><span class="line">		if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">			// 尝试设置 mutexWoken 标志来通知解锁，以避免唤醒其他阻塞的 goroutine</span><br><span class="line">			if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp; </span><br><span class="line">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">				awoke = true</span><br><span class="line">			&#125;</span><br><span class="line">			runtime_doSpin()</span><br><span class="line">			iter++</span><br><span class="line">			old = m.state // 再次获取锁的状态，后面会检查锁是否被释放了</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">        new := old</span><br><span class="line">        if old&amp;mutexStarving == 0 &#123;</span><br><span class="line">			new |= mutexLocked // 非饥饿状态，加锁</span><br><span class="line">		&#125;</span><br><span class="line">		if old&amp;(mutexLocked|mutexStarving) != 0 &#123;</span><br><span class="line">			new += 1 &lt;&lt; mutexWaiterShift // waiter 数量加 1</span><br><span class="line">		&#125;</span><br><span class="line">        if starving &amp;&amp; old&amp;mutexLocked != 0 &#123;</span><br><span class="line">			new |= mutexStarving // 设置饥饿状态</span><br><span class="line">		&#125;</span><br><span class="line">		if awoke &#123;</span><br><span class="line">			// The goroutine has been woken from sleep, </span><br><span class="line">			// so we need to reset the flag in either case. </span><br><span class="line">			if new&amp;mutexWoken == 0 &#123;</span><br><span class="line">				throw(&quot;sync: inconsistent mutex state&quot;)</span><br><span class="line">			&#125;</span><br><span class="line">			new &amp;^= mutexWoken // 新状态清除唤醒标记</span><br><span class="line">		&#125;</span><br><span class="line">        // 设置新状态</span><br><span class="line">		if atomic.CompareAndSwapInt32(&amp;m.state, old, new) &#123;</span><br><span class="line">            // 再次检查，原来锁的状态已释放，并且不是饥饿状态，正常请求到了锁，返回</span><br><span class="line">			if old&amp;(mutexLocked|mutexStarving) == 0 &#123;</span><br><span class="line">				break // locked the mutex with CAS</span><br><span class="line">			&#125;</span><br><span class="line">			// 处理饥饿状态</span><br><span class="line">			// 如果之前就在该队列里面，就加入到队列头</span><br><span class="line">			queueLifo : waitStartTime != 0</span><br><span class="line">			if waitStartTime == 0 &#123;</span><br><span class="line">				waitStartTime = runtime_nanotime()</span><br><span class="line">			&#125;</span><br><span class="line">            // runtime_SemacquireMutex 通过信号量保证资源不会被两个 goroutine 获取</span><br><span class="line">			// runtime_SemacquireMutex 会在方法中不断尝试获取锁并陷入休眠等待信号量的释放</span><br><span class="line">			// 也就是这里会阻塞等待</span><br><span class="line">			// 一旦当前 goroutine 可以获取信号量，它就会立刻返回，剩余代码也会继续执行</span><br><span class="line">			runtime_SemacquireMutex(&amp;m.sema, queueLifo, 1)</span><br><span class="line">			// 在正常模式下，这段代码会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环</span><br><span class="line">            // 在饥饿模式下，当前 goroutine 会获得锁，如果等待队列中只存在当前 goroutine，锁还会从饥饿模式中退出</span><br><span class="line">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">			old = m.state</span><br><span class="line">			if old&amp;mutexStarving != 0 &#123;</span><br><span class="line">				if old&amp;(mutexLocked|mutexWoken) != 0 || old&gt;&gt;mutexWaiterShift == 0 &#123;</span><br><span class="line">					throw(&quot;sync: inconsistent mutex state&quot;)</span><br><span class="line">				&#125;</span><br><span class="line">				delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift)</span><br><span class="line">				if !starving || old&gt;&gt;mutexWaiterShift == 1 &#123;</span><br><span class="line">					delta -= mutexStarving</span><br><span class="line">				&#125;</span><br><span class="line">				atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">				break</span><br><span class="line">			&#125;</span><br><span class="line">			awoke = true</span><br><span class="line">			iter = 0</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if race.Enabled &#123;</span><br><span class="line">		race.Acquire(unsafe.Pointer(m))</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h4><p>自旋是一种多线程同步机制，<strong>当前的进程在进入自旋的过程中会一直保持 CPU 的占用</strong>，持续检查某个条件是否为真。在多核的 CPU 上，自旋可以避免 goroutine 的切换， 使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 goroutine 进入自旋的条件非常苛刻：</p>
<ol>
<li><code>old&amp;(mutexLocked|mutexStarving) == mutexLocked</code> 只有在普通模式</li>
<li><code>runtime_canSpin(iter)</code> 为真：<ul>
<li>运行在多 CPU 的机器上</li>
<li>自旋的次数小于四次</li>
<li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空</li>
</ul>
</li>
</ol>
<h3 id="Mutex-Unlock-的实现"><a href="#Mutex-Unlock-的实现" class="headerlink" title="Mutex.Unlock() 的实现"></a>Mutex.Unlock() 的实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">func (m *Mutex) Unlock() &#123;</span><br><span class="line">	if race.Enabled &#123;</span><br><span class="line">		_ = m.state</span><br><span class="line">		race.Release(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Fast path: drop lock bit.</span><br><span class="line">	// new == 0 成功释放锁</span><br><span class="line">	new := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">	if new != 0 &#123;</span><br><span class="line">		// Outlined slow path to allow inlining the fast path.</span><br><span class="line">		// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.</span><br><span class="line">		m.unlockSlow(new)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *Mutex) unlockSlow(new int32) &#123;</span><br><span class="line">	if (new+mutexLocked)&amp;mutexLocked == 0 &#123; // unlock 一个未加锁的锁</span><br><span class="line">		fatal(&quot;sync: unlock of unlocked mutex&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if new&amp;mutexStarving == 0 &#123; // 正常模式</span><br><span class="line">		old := new</span><br><span class="line">		for &#123;</span><br><span class="line">			// 不存在等待者 或者 mutexLocked、mutexStarving、mutexWoken 状态不都为 0</span><br><span class="line">			// 则不需要唤醒其他等待者</span><br><span class="line">			if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 &#123;</span><br><span class="line">				return</span><br><span class="line">			&#125;</span><br><span class="line">			// 存在等待者，通过 runtime_Semrelease 唤醒等待者并移交锁的所有权</span><br><span class="line">			new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">			if atomic.CompareAndSwapInt32(&amp;m.state, old, new) &#123;</span><br><span class="line">				runtime_Semrelease(&amp;m.sema, false, 1)</span><br><span class="line">				return</span><br><span class="line">			&#125;</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123; // 饥饿模式</span><br><span class="line">		// 直接调用 runtime_Semrelease 将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时还不会退出饥饿状态</span><br><span class="line">		runtime_Semrelease(&amp;m.sema, true, 1)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-sync-RWMutex"><a href="#3-sync-RWMutex" class="headerlink" title="3.sync.RWMutex"></a>3.sync.RWMutex</h2><p>读写互斥锁 <code>sync.RWMutex</code> 是细粒度的互斥锁，一般来说有几种情况：</p>
<ul>
<li>读锁之间不互斥</li>
<li>写锁之间是互斥的</li>
<li>写锁与读锁是互斥的<br><code>sync.RWMutex</code> 类型中的 <code>Lock</code> 方法和 <code>Unlock</code> 方法用于对写锁进行锁定和解锁，<code>RLock</code> 方法和 <code>RUnlock</code> 方法则分别用于对读锁进行锁定和解锁。</li>
</ul>
<h2 id="4-sync-WaitGroup"><a href="#4-sync-WaitGroup" class="headerlink" title="4.sync.WaitGroup"></a>4.sync.WaitGroup</h2><p><code>sync.WaitGroup</code> 可以等待一组 goroutine 的返回，常用于处理批量的并发任务。它是并发安全的。<br><code>WaitGroup</code> 提供了三个方法：</p>
<ul>
<li><code>Add</code>：用来设置 <code>WaitGroup</code> 的计数值。</li>
<li><code>Done</code>：用来将 <code>WaitGroup</code> 的计数值减 1，其实就是调用了 <code>Add(-1)</code>。</li>
<li><code>Wait</code>：调用这个方法的 <code>goroutine</code> 会一直阻塞，直到 <code>WaitGroup</code> 的计数值变为 0。<br>不要把 <code>Add</code> 和 <code>Wait</code> 方法的调用放在不同的 goroutine 中执行，以免 <code>Add</code> 还未执行，<code>Wait</code> 已经退出<br>尽量不要重用 <code>WaitGroup</code>。新建一个 <code>WaitGroup</code> 不会带来多大的资源 开销，重用反而更容易出错。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// src/sync/cond.go#L117</span><br><span class="line">type noCopy struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Lock is a no-op used by -copylocks checker from `go vet`.</span><br><span class="line">func (*noCopy) Lock()   &#123;&#125;</span><br><span class="line">func (*noCopy) Unlock() &#123;&#125;</span><br></pre></td></tr></table></figure>
<code>noCopy</code> 是 go 1.7 开始引入的一个静态检查机制，它只是一个辅助类型<code>tools/go/analysis/passes/copylock</code> 包中的分析器会在编译期间检查被拷贝的变量中是否包含 <code>noCopy</code> 或者实现了 <code>Lock</code> 和 <code>Unlock</code> 方法，如果包含该结构体或者实现了对应的方法就会报错</li>
</ul>
<h3 id="关于noCopy"><a href="#关于noCopy" class="headerlink" title="关于noCopy"></a>关于noCopy</h3><p><code>noCopy</code> 类型以及相关的 <code>Lock</code> 和 <code>Unlock</code> 方法的设计主要是为了防止某些结构体被意外拷贝</p>
<p>以下是一些通常需要不可拷贝属性的类：</p>
<ul>
<li><strong>资源管理类</strong>：比如文件操作类，若允许拷贝，可能导致多个副本同时操作同一个文件，引发数据混乱或文件资源被滥用。再如数据库连接管理类，拷贝该类实例可能造成多个副本同时连接数据库，超出数据库连接池的限制，影响系统性能和稳定性。</li>
<li><strong>状态管理类</strong>：像游戏中的角色状态类，每个角色的状态是唯一且独立的，若进行拷贝，可能导致角色状态混乱，影响游戏逻辑。还有 Web 应用中的用户会话管理类，每个用户的会话状态是特定的，拷贝会话管理类实例可能导致用户状态混淆，引发安全问题或错误的业务逻辑。</li>
<li><strong>单例类</strong>：单例模式确保一个类只有一个实例存在于系统中。若允许拷贝单例类，就会破坏单例模式的唯一性，可能导致系统中出现多个不同状态的 “单例” 实例，引发逻辑错误和资源管理混乱。</li>
<li><strong>并发控制类</strong>：例如使用互斥锁（Mutex）来控制并发访问的类，若可拷贝，可能会出现多个副本同时尝试获取锁，导致并发控制失效，引发数据竞争和不一致性问题。</li>
<li><strong>内部有唯一标识或指针的类</strong>：当类内部包含唯一标识（如 UUID）或指针指向特定的内存区域、外部资源时，拷贝该类可能导致多个实例拥有相同的标识或指向相同的资源，进而引发冲突或资源管理错误。</li>
</ul>
<p>静态分析代码：<br><code>go vet</code> 工具属于 Go 标准库的一部分，其工作原理是对代码进行静态分析，也就是在不运行代码的情况下分析代码的结构与语义。在使用 <code>-copylocks</code> 检查器时，<code>go vet</code> 会执行以下操作：<br><strong>1.解析代码</strong><br><code>go vet</code> 会对代码进行解析，构建抽象语法树（AST）。抽象语法树是代码的一种树形表示，它能体现代码的语法结构。<br><strong>2.查找 <code>noCopy</code> 字段</strong><br><code>go vet</code> 会遍历抽象语法树，查找包含 <code>noCopy</code> 类型字段的结构体。当发现这样的结构体时，它会记录下来。<br><strong>3.检查拷贝操作</strong><br>接着，<code>go vet</code> 会查找代码里对这些包含 <code>noCopy</code> 字段的结构体进行拷贝的操作。拷贝操作可能有以下几种情况：赋值，函数参数传递，函数返回值。<br><strong>4.发出警告</strong><br>一旦 <code>go vet</code> 发现对包含 <code>noCopy</code> 字段的结构体进行了拷贝操作，就会发出警告，提醒开发者可能存在的问题。</p>
<h2 id="5-sync-Cond"><a href="#5-sync-Cond" class="headerlink" title="5.sync.Cond"></a>5.sync.Cond</h2><p><code>sync.Cond</code> 基于互斥锁&#x2F;读写锁<br>和互斥锁的区别：<br>互斥锁 <code>sync.Mutex</code> 通常用来保护临界区和共享资源，条件变量 <code>sync.Cond</code> 用来协调想要访问共享资源的 goroutine。<br><code>sync.Cond</code> 经常用在多个 goroutine 等待，一个 goroutine 通知的场景。<br><code>NewCond</code> 用来创建 <code>sync.Cond</code> 实例，<code>sync.Cond</code> 暴露了几个方法：</p>
<ul>
<li><code>Broadcast</code> 用来唤醒所有等待条件变量的 goroutine，无需锁保护。</li>
<li><code>Signal</code> 唤醒一个 goroutine。</li>
<li><code>Wait</code> 调用 <code>Wait</code> 会自动释放锁，并挂起调用者所在的 goroutine，也就是当前 goroutine 会阻塞在 <code>Wait</code> 方法调用的地方。如果其他 goroutine 调用了 <code>Signal</code> 或 <code>Broadcast</code> 唤醒 了该 goroutine，那么 <code>Wait</code> 方法在结束阻塞时，会重新加锁，并且继续执行 <code>Wait</code> 后面的代码。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var status int64</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">	for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		go listen(c)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(1 * time.Second)</span><br><span class="line">	go broadcast(c)</span><br><span class="line"></span><br><span class="line">	ch := make(chan os.Signal, 1)</span><br><span class="line">	signal.Notify(ch, os.Interrupt)</span><br><span class="line">	&lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func broadcast(c *sync.Cond) &#123;</span><br><span class="line">	c.L.Lock()</span><br><span class="line">	atomic.StoreInt64(&amp;status, 1)</span><br><span class="line">	c.Broadcast()</span><br><span class="line">	c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func listen(c *sync.Cond) &#123;</span><br><span class="line">	c.L.Lock()</span><br><span class="line">	for atomic.LoadInt64(&amp;status) != 1 &#123; </span><br><span class="line">		c.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;listen&quot;)</span><br><span class="line">	c.L.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>status</code>：互斥锁需要保护的条件变量。</li>
<li><code>listen()</code> 调用 <code>Wait()</code> 等待通知，直到 <code>status</code> 为 1。</li>
<li><code>broadcast()</code> 将 <code>status</code> 置为 1，调用 <code>Broadcast()</code> 通知所有等待的 goroutine。</li>
</ul>
<h2 id="6-sync-Once"><a href="#6-sync-Once" class="headerlink" title="6.sync.Once"></a>6.sync.Once</h2><p>Go 标准库中 <code>sync.Once</code> 可以保证 Go 程序运行期间的某段代码只会执行一次。常常用于单例对象的初始化场景。<br><code>sync.Once</code> 只有一个对外唯一暴露的方法 <code>Do</code>，可以多次调用，但是只第一次调用时会执行一次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    o := &amp;sync.Once&#123;&#125;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        o.Do(func() &#123;</span><br><span class="line">            fmt.Println(&quot;only once&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">only once</span><br></pre></td></tr></table></figure>
<h2 id="7-Context"><a href="#7-Context" class="headerlink" title="7.Context"></a>7.Context</h2><p>主要的作用是在在一组 goroutine 之间传递共享的值、取消信号、deadline 等。<code>context.Context</code>并不是一个具体的实现，而是一个定义了一组方法的接口，Context接口共有四个方法。</p>
<ul>
<li><code>Deadline</code> — 返回当前 context 的截止时间。</li>
<li><code>Done</code> — 返回一个只读的 channel，可用于识别当前 channel 是否已经被关闭，其原因可能是到期，也可能是被取消了。多次调用 <code>Done</code> 方法会返回同一个 channel。</li>
<li><code>Err</code> — 返回当前 context 被关闭的原因。<ul>
<li>如果 context 被取消，会返回 <code>Canceled</code> 错误。</li>
<li>如果 context 超时，会返回 <code>DeadlineExceeded</code> 错误。</li>
</ul>
</li>
<li><code>Value</code> — 返回当前 context 对应所存储的 context信息，可以用来传递请求特定的数据。<br>创建 context：</li>
<li><code>Background</code>：创建一个空的 context，一般用在主函数、初始化、测试以及创建 root context 的时候。</li>
<li><code>TODO</code>：创建一个空的 context，不知道要传递一些什么上下文信息的时候，就用这个。</li>
<li><code>WithCancel</code>：基于 parent context 创建一个可以取消的新 context。</li>
<li><code>WithTimeout</code>：基于 parent context 创建一个具有<strong>超时时间</strong>的新 context。</li>
<li><code>WithDeadline</code>：和 <code>WithTimeout</code> 一样，只不过参数是<strong>截止时间</strong>（超时时间加上当前时间）。</li>
<li><code>WithValue</code>：基于某个 context 创建并存储对应的上下文信息。</li>
</ul>
<h1 id="6-atomic包（原子操作）"><a href="#6-atomic包（原子操作）" class="headerlink" title="6.atomic包（原子操作）"></a>6.atomic包（原子操作）</h1><p>Go 的标准库 <code>sync/atomic</code> 提供了一些实现原子操作的方法：</p>
<ul>
<li>Add</li>
<li>CompareAndSwap（简称 CAS）</li>
<li>Load</li>
<li>Swap</li>
<li>Store<br><strong>互斥锁与原子操作</strong><br>区别：</li>
<li><strong>互斥锁是用来保护临界区，原子操作用于对一个变量的更新保护</strong>。</li>
<li>互斥锁由操作系统的调度器实现，原子操作由底层硬件指令直接提供支持。<br>使用互斥锁实现并发计数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func MutexAdd() &#123;</span><br><span class="line">	var a int32 =  0</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	var mu sync.Mutex</span><br><span class="line">	start := time.Now()</span><br><span class="line">	for i := 0; i &lt; 10000; i++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			defer wg.Done()</span><br><span class="line">			mu.Lock()</span><br><span class="line">			a += 1</span><br><span class="line">			mu.Unlock()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	timeSpends := time.Now().Sub(start).Nanoseconds()</span><br><span class="line">    fmt.Printf(&quot;mutex value %d, spend time: %v\n&quot;, a, timeSpends)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用原子操作替换互斥锁：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func AtomicAdd() &#123;</span><br><span class="line">	var a int32 =  0</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	start := time.Now()</span><br><span class="line">	for i := 0; i &lt; 10000; i++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			defer wg.Done()</span><br><span class="line">			atomic.AddInt32(&amp;a, 1)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	timeSpends := time.Now().Sub(start).Nanoseconds()</span><br><span class="line">    fmt.Printf(&quot;atomic value %d, spend time: %v\n&quot;, atomic.LoadInt32(&amp;a), timeSpends)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</div>
        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <span itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</span>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
            
            
                <div class="post-actions text-center clearfix" id="post-actions">
                
                    <a class="donate" href="javascript:;" onclick="krOpenDonateModal()"><i class="fa fa-bitcoin"></i> 打赏</a>
                
                
                    <a class="share" href="javascript:;" onclick="krOpenShareModal()"><i class="fa fa-share-alt"></i> 分享</a>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    
                </div>
                <div class="pull-date">
                    <time datetime="2025-06-28T09:08:59.900Z" itemprop="dateModified">最后编辑：2025-06-28</time>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" 计算机网络" href="/2024/11/14/计算机网络/"><i class="fa fa-angle-left"></i> 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" 每日搓安卓组件" href="/2025/05/18/每日搓安卓组件/">下一篇 <i class="fa fa-angle-right"></i></a>
            </div>
            
        </nav>
    
    
        <div class="comment-post">
            
        </div>
    
</article>

        

            </section>

            
                

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="image/img2.jpg" alt="John Doe" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center"></p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                6
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                0
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                0
            </span>
        </a>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                

            
                
            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2025/06/28/Android-Runtime/"><i class="fa fa-book"></i> Android_Runtime</a>
            
          
        
          
          
            <a class="list-group-item" href="/2025/05/18/%E6%AF%8F%E6%97%A5%E6%90%93%E5%AE%89%E5%8D%93%E7%BB%84%E4%BB%B6/"><i class="fa fa-book"></i> 每日搓安卓组件</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/12/17/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><i class="fa fa-book"></i> golang并发编程</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/11/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><i class="fa fa-book"></i> 计算机网络</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/11/09/%E6%A0%91/"><i class="fa fa-book"></i> 树</a>
            
          
        
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
            

        

                </div>
    </div>
</div>

<footer>
    <div id="footer">
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2025 Kid 版权所有.</li>
                            <li>本站已运行<span id="kr-since">Loading...</span></li>
                        </div>
                        <div>
                            <li>自豪地使用 <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a> 主题</li>
                            <li>站点由 John Doe 用 <i class="fa fa-heart" style="color:#d43f57"></i> 搭建</li>
                        </div>
                        <!-- 额外的追加注入项 -->
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                <div class="box theme-box" id="theme-toggle">
                    <span class="fa fa-adjust"></span>
                </div>
            </div>
            <div id="gotop-box" class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>


    <div id="kr-donate-modal" class="kr-modal">
    <div class="kr-modal-bg" onclick="krCloseDonateModal()"></div>
    <div class="kr-modal-content">
        <div class="kr-modal-header">
            <div class="kr-modal-icon">
                <i class="fa fa-bitcoin"></i>
            </div>
            <div class="kr-modal-title">赞助喵</div>
            <button class="kr-modal-close" onclick="krCloseDonateModal()">
                <i class="fa fa-times-circle"></i>
            </button>
        </div>
        <div class="kr-modal-body">
            <div class="kr-donate-message">非常感谢您的喜欢！ <i class="fa fa-heart" style="color:#d43f57"></i></div>
            <div class="kr-donate-qr" id="kr-donate-qr">
                
                    <img class="kr-donate-placeholder" src="https://dev.krt.moe/demo-assets/donate.webp" alt="赞助喵" />
                
            </div>
            <div class="kr-donate-platforms">
                
                    
                        <button class="kr-donate-platform-button" style="color: skyblue;" title="模拟支付" onclick="krDonateModalShowPlatformQR('example_payment', 'skyblue')">
                            <i class="fa fa-credit-card"></i>
                        </button>
                    
                
            </div>
        </div>
    </div>
</div>
<script defer src="/js/kr-modal/donate.min.js"></script>




    <div id="kr-share-modal" class="kr-modal">
    <div class="kr-modal-bg" onclick="krCloseShareModal()"></div>
    <div class="kr-modal-content">
        <div class="kr-modal-header">
            <div class="kr-modal-icon">
                <i class="fa fa-share-alt"></i>
            </div>
            <div class="kr-modal-title">分享这一刻</div>
            <button class="kr-modal-close" onclick="krCloseShareModal()">
                <i class="fa fa-times-circle"></i>
            </button>
        </div>
        <div class="kr-modal-body">
            <div class="kr-share-message">让朋友们也来瞅瞅！</div>
            <div class="kr-share-qr" id="kr-share-qr"></div>
            <div class="kr-share-platforms">
                
                    <button class="kr-share-platform-button" style="color: #62b6e7;" title="喵窝" onclick="krShareModalOpenPlatform('https://nya.one/share?text=%3E%20$TITLE%0A%3E%0A%3E%20$SUMMARY%0A----%20$SITE%0A%0A$URL')">
                        <svg fill="currentColor" width="18" height="18" viewBox="0 0 329 388"><path d="M0,36.226c0,-19.993 16.233,-36.226 36.226,-36.226c13.788,0 25.787,7.719 31.908,19.068l188.366,229.845l0,-111.259c-6.356,5.508 -14.645,8.843 -23.707,8.843c-19.994,0 -36.226,-16.232 -36.226,-36.226c-0,-8.551 2.968,-16.413 7.93,-22.613l-0.015,-0.013l56.614,-69.08c6.2,-11.073 18.047,-18.565 31.63,-18.565c19.994,0 36.227,16.233 36.227,36.226l-0,314.644c-0,19.994 -16.233,36.226 -36.227,36.226c-13.166,0 -24.701,-7.039 -31.044,-17.555l-189.229,-230.899l-0,212.228c-0,19.994 -16.233,36.226 -36.227,36.226c-19.993,0 -36.226,-16.232 -36.226,-36.226l0,-314.644Z" /></svg>
                    </button>
                
            </div>
        </div>
    </div>
</div>
<script defer src="/js/kr-modal/share.min.js"></script>



<!-- 额外的追加注入项 -->


        <script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


  <script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>



  <script defer src="/vendors/viewerjs@1.11.6/dist/viewer.min.js"></script>


<script defer src="/js/kr-core.min.js"></script>


  <script defer src="/js/kr-pjax.min.js"></script>


<!-- 额外的追加注入项 -->


    </body>
</html>